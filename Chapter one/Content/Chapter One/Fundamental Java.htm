<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="2" MadCap:lastHeight="829.4" MadCap:lastWidth="625">
    <head>
        <link href="../Resources/Stylesheets/Bookstyle.css" rel="stylesheet" />
    </head>
    <body>
        <h1 class="title">Fundamental Java</h1>
        <h1 class="Heading1">Data Primitives</h1>
        <p>Java has nine built-in data types, called primitives. These include the numeric types: integers and floating point numbers; individual character types; and the <code>boolean</code> type, which has a value of true or false. Using these types, it is possible to build up many useful data structures, but the core of Java is <i>objects</i>. Objects are what give Java it’s power and flexibility, and much of this book will be devoted to working with them. For now, we are concerned with the lowest-order building blocks. Not all languages have primitive types. Ruby, for example, treats all primitives as objects. For reasons of performance, the developers of Java elected to keep primitive types, though they cannot be operated on in the same way as objects. Java does, however, provide facilities to treat  data primitives like objects, where needed -- more about that later. (insert cross reference)</p>
        <p class="HeadingRunIn" MadCap:autonum="1.1 ">decimal integer types</p>
        <p>Java provides four integer types: <code>byte</code>, <code>short</code>, <code>int</code>, and <code>long</code>. <code>Byte</code> will only hold numbers from -128 to + 127. <code>Short</code> runs from -32768 to + 32767. <code>Int</code> will hold values from -2,147,483,648 to +2,147,483,647. </p>
        <p>The type <code>long</code> holds from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807. The types <code>byte</code> and <code>short</code> are not used except where memory is at an absolute premium. By far the most common integer type is <code>int</code>. See the accompanying graphic for a representation of decimal integer types and the amount of data they will hold. (graphic showing the bit depth and maximum absolute values of integer types) </p>
        <p class="HeadingRunIn" MadCap:autonum="1.2 ">floating point types</p>
        <p>They are called floating point because the decimal point “floats.” The decimal point is also referred to as the “radix.” Floating point numbers are a bit more complex than integers.</p>
        <p>Oddly, the number of decimal places and the accuracy differ. It’s a kind of trade off between scale and precision. <code>Float</code> will hold up to four bytes of data, from -3.4E38 to +3.4E38. This is a shorthand way of writing 3.4 * 10^38. However, the accuracy is only to seven significant digits. In case that’s not confusing enough, floating point types will also hold a larger number of places closer to the origin than further from the origin. In other words, you can write small numbers to a higher number of decimal places than large ones. The smallest value that type <code>float</code> will hold is approximately -1.4E45. </p>
        <p>Type <code>double</code> will hold eight bytes of data. The general specification for numbers of type <code>double</code> is -/+ 1.7E308; the smallest <code>double</code> is approximately -4.9E324. However, though the capacity to hold numbers is massive, the accuracy is only to 17 significant digits. </p>
        <p>Most developers use <code>double</code> as their default floating point type. The Java math library, which contains standard mathematical methods, uses <code>double</code> for most operations, and this avoids the need to convert between types. (insert cross reference) Type <code>float</code> is reserved for memory conservation purposes.</p>
        <p>When type <code>float</code> is used, an <code>f</code> or <code>F</code> must be appended. Examples:</p><pre>double pi = 3.14159;</pre><pre>float aFloat = 2.65f;</pre>
        <p class="HeadingRunIn" MadCap:autonum="1.3 ">character types</p>
        <p>Character types are individual characters. When Java was originally released, it used the ASCII character set, based upon the English language, which includes support for only 128 characters. Current releases of Java instead use Unicode, which provides over 110,000 characters, including support for Cyrillic, Arabic, phonetic Japanese, and other alphabets. Support is also available for a wide variety of symbols, from currency symbols to mathematical operators. (insert </p>
        <p>Characters in succession are known as <code>String</code> types. Many <code>String</code> methods operate on <code>char</code> types.  Among the more important <code>char</code> type operations on strings are; decomposition; ordering; identifying; changing case; and changing position. It is also useful to understand how Java uses the type <code>char</code> in Strings. Java uses <i>data </i><cite>streams</cite>for input and output, whether from a keyboard, to the monitor or a printer, or to an external database. Streams are either binary data or characters; the group of characters which comprise a String is recognized as a stream of individual <code>char</code> types. We will deal more extensively with these operations when we discuss character data streams. (insert cross reference)</p>
        <p class="">Characters are also used in <i>escape sequences.</i>Escape sequences are reserved for characters which cannot be entered by default from the keyboard. Many of these are <i>control characters,</i> which control the output of text written to the console, that is, the monitor, by inserting a tab, a new line, etc. For example, the escape sequence for a new line is <code>\n</code>.Printing to the console, or monitor, makes extensive use of control characters to control the appearance of output. Another use for escape sequences is to enter a symbol or other special character. Thus, to insert the symbol for Sterling, <span class="_Override" style="font-family: Inconsolata;font-size: 11pt;line-height: 13pt;">£,</span>type <code>\u00A3,</code> which is the hexadecimal value for the symbol in Unicode. Escape sequences are always preceded by the backslash character, \, the letter u, and generally employ Unicode, though other encoding schemes are recognized. (insert table of control characters)</p>
        <p class="HeadingRunIn" MadCap:autonum="1.4 ">boolean types</p>
        <p>Boolean types have the values <code>true</code> or <code>false</code>. In Java, boolean types are used most frequently for logical control over the way a program executes. (insert cross reference) By combining values with the boolean modifiers <i>and, or, </i>and <i>not,</i> sophisticated logical structures may be produced. A simple example is the two elements necessary for drinking alcohol legally: being 21 and having ID to prove it. But there are times when another control structure might be preferred, for example the contrapositive, which both inverts and negates a conditional statement. The conditional statement, if you are 21 and have ID, then you can order a drink may be recast. You cannot order a drink if you are not 21 or do not have ID. In practice, this flexibility is important. In fact, more often than not, it is the negated form which warns away underage patrons from a bar or package store!</p>
        <h1 class="Heading1">Variables</h1>
        <p class="HeadingRunIn" MadCap:autonum="1.5 ">variable declaration and initialization</p>
        <p>Variables in Java are also known as <i>identifiers</i>. The creation of a variable is called <i>declaration </i>and assigning it a value is called <i>initialization. Variables in Java are always associated with a type.</i> A correct variable declaration is of the form:</p><pre>int number;</pre>
        <p>Thus identifying the variable by both name and type. Note as well the semi-colon which terminates the line. Every statement in Java must terminate with a semi-colon. To then initialize the variable with a value, the syntax is:</p><pre>int number = 8;</pre>
        <p>Note the <code>=</code> sign. The equals sign takes on a multiplicity of new and unaccustomed roles in Java -- not the greatest virtue of the language. Here, the equals sign functions to initialize <code>int number</code>. <i>This is not an equality statement. There is no reflexive property; the statement cannot be reversed. And there are even situations in which the assignment statement creates two unequal operands on either side. </i>(insert cross reference)<i>  <![CDATA[ ]]></i></p>
        <p>Variables may also be assigned to other variables:</p><pre>int number = quantity;</pre><pre>int quantity = amount;</pre><pre>int amount = number;</pre>
        <p>Java variables should be named using clear, descriptive language. This leads to readable, maintainable code; cryptic, anonymous names leads to code which conversely is difficult to read and maintain. Long variables names are a best practice in Java, though one honored often in the breach. </p><pre>int bicycleWheelSize;</pre>
        <p>is preferable to:</p><pre>int size;</pre>
        <p>and markedly preferable to:</p><pre>int s;</pre>
        <p>which says nothing about the meaning of the variable. There is informed thinking behind the decision to call Java variables “identifiers.” They should identify data, not merely name it.</p>
        <p>An exception to the rule concerning long identifiers is for mathematical variables or for variables which are scoped locally to a method (insert cross reference). The math convention of using single-letter variable names is generally followed. For locally-scoped variables, it depends upon the context. The priorities are always clarity first, compactness second. (insert cross reference)</p>
        <p>Note also the use of <cite>lowerCamelCase</cite>, in which the first word is written with lower case, subsequent words with upper case. This is not strictly necessary, merely conventional. Identifiers in Java can begin with a dollar sign, an underscore, or a letter. Numerals are not permitted. The rest of the identifier can use any symbol, except those reserved as operators. Any word is acceptable, except for a reserved word. (table of reserved words) Java is case sensitive, so <code>BicycleWheel</code> is not the same as <code>bicycleWheel</code>. Because of the potential for conflict with reserved operators, using special characters or other symbols in a variable name is not a best practice, nor do Java variables conventionally begin with a dollar sign or underscore. Best practice is to use letters to begin a variable name, and a combination of letters and numbers in the remainder of the name.</p>
        <p>Type integrity is required in naming variables. Java is a strongly typed language; no variable may exist without a data type. This applies not only to primitive data types, but all data types, including those created by the user:</p>
        <p style="font-family: 'Courier New';font-weight: normal;font-style: normal;font-size: 12pt;letter-spacing: 0em;color: #000000;text-decoration: none;"><code>Clothing trousers = denim;</code>
        </p>
        <p>initializes the identifier <code>trousers</code>, of type <code>Clothing</code>, with the value <code>denim</code>.</p>
        <p class="HeadingRunIn" MadCap:autonum="1.6 ">literals</p>
        <p>Values may also be declared without variables, as <i>literals</i> or <i>constants</i>. Such values need not be declared or initialized. Often, they are used as part of an <i>expression</i>. An expression is simply a statement which evaluates to a specific value. You can write:</p><pre>int number;</pre><pre>number = 18 + 3;</pre>
        <p>Without declaring variables for <code>18</code> and <code>3</code>. However, you cannot simply declare an integer or another primitive value, unless you use a variable. The statement:</p><pre>int = 21;</pre>
        <p>is not legal. Java will construe it as a variable declaration without a name instead of recognizing it as a literal.</p>
        <p>By the same token:</p><pre>boolean = true;</pre>
        <p>Is not a legal statement. Instead, you must write:</p><pre>boolean isSwitchedOn = true;</pre>
        <p>Care must be exercised in the use of literals. Literals can be difficult to parse for somebody else reading your code. In the above statement, what do the literal values <code>18</code> and <code>3</code> correspond to? Let’s look at them in another context.</p><pre>int diameter = 18 + 3;</pre>
        <p>If instead of a book, this were an architectural program, suddenly those “magic numbers” would begin looking fishier. Maybe they are dimensions? But if so, dimensions of what? Here’s another, more bulletproof way to write that code;</p><pre xml:space="preserve">int totalDiameter;</pre><pre xml:space="preserve">int innerDiameter = 3;</pre><pre xml:space="preserve">int outerDiameter = 18;</pre><pre xml:space="preserve">totalDiameter = innerDiameter + outerDiameter;</pre>
        <p>The variables are much clearer than the “magic numbers,” and code of any sophistication uses variables wherever possible.</p>
        <p>A best practice with regard to the use of literals is in the case of <i>constants</i>. Constants should be declared using the <i>final</i> keyword. Constant names are by convention capitalized. Variables declared as final cannot be changed without changing the statement containing the final modifier. A constant would be written as follows.</p><pre xml:space="preserve"><code>final int TOTAL_DIAMETER = 21;</code></pre>
        <p>One additional note concerning literals. For primitives of type <code>char</code>, literals must be enclosed within single quotes. </p><pre xml:space="preserve"><code>char character = 'u';</code></pre>
        <h1>Mathematical Operations</h1>
        <p>Java uses the ordinary symbols for addition, subtraction, multiplication, and division: +, -, *, and /. To this it adds a fifth operation, %, for modulus, which is simply the remainder of integer division. The order of operations is the same as that used in arithmetic, so mixed expressions evaluate multiplication and division before addition and subtraction. Parentheses can also be used to control order of operations in the usual fashion. </p>
        <p class="HeadingRunIn" MadCap:autonum="1.7 ">the assignment statement</p>
        <p>The equals sign is also used for an <i>assignment statement</i>:</p><pre>areaCircle = pi * radius * radius;</pre>
        <p>Java contains a library value for pi, so there’s no need to define it in this fashion as a variable, but we’ll use it that way for now.  The assignment statement is distinct from variable declaration and initialization. When creating a variable, memory is initialized to the value of the variable; when creating an assignment, data moves from one location to another in memory. In an assignment statement, computation is performed. When a variable is declared or declared and initialized, there’s no computation, merely a reference to the variable created in memory. A variable must be created before it can be assigned; it need not be <i>initialized </i>before it is assigned. The point concerning computation is a practical one. <i>No computation can be performed before a variable has been initialized with a value</i>. Remembering that an assignment statement involves computation will help you to remember this rule. Again, note that the assignment statement is <i>not</i> an equality statement. I am flogging this horse because it is so easy a mistake to make; all our lives, we have been accustomed to treat an equals sign as an indication that the two sides of an equation are equal. Not in Java, at least not in the usual sense. </p>
        <p>Let’s examine another assignment statement:</p><pre>final int AREA_CIRCLE = pi * radius * radius;</pre>
        <p>Here, the variable <code>AREA_CIRCLE</code> is defined for the first time in the assignment statement, so it is identified by type and is capitalized because we want to use it as a constant. Capitalization is not required, but it is conventional in Java to capitalize constant values. The keyword <code>final</code>identifies the variable as constant; the formula for the area of a circle does not change. Again, this is not necessary, but conventional. The keyword <code>final</code> prevents alteration of the statement. Any attempt to change it returns an error message. (insert table for variables, literals, assignment, constants)</p>
        <p class="HeadingRunIn" MadCap:autonum="1.8 ">casting</p>
        <p>It is sometimes necessary to convert between types. For example, if a variable declared to be of type <code>int</code> experiences overflow, it is necessary to convert it to type <code>long</code>. In such a case, where the value is being increased and there is no potential for loss of data, Java will automatically convert the type in a process called <i>casting. </i>However, where the conversion can result in a loss of precision, the cast must be performed manually, in a process called <i>explicit casting.</i> Explicit casting is a safeguard to prevent the user from inadvertently losing precision. For example, if a variable is of type <code>int</code> and the attempt is made to assign to it a value of type <code>double</code>, an error message “possible loss of precision” is returned. The code:</p><pre>double number = 4.4;</pre><pre>int integer = number * 6;</pre>
        <p>is incorrect. Because of strict typing in Java, the compiler looks for an <code>int</code> type on the right hand side of the assignment statement. It is necessary to perform an explicit cast:</p><pre>double number = 4.4;</pre><pre>int integer = (int)number * 6;</pre>
        <p>thus converting the <code>double number</code> to type <code>int</code>.</p>
        <p>Casting is not limited to primitive types. It is also done on other types; in fact on any type where appropriate. (insert cross reference) Care must be used when manually casting to avoid unanticipated errors; it should be avoided as a best practice, though there are times when it is unavoidable. Especially in somebody else’s code.</p>
        <p>And a final point concerning casting. While intuitively, one would expect Java to round up or down when casting floating point to integer types, in fact it merely truncates the least significant digits: those to the right of the decimal point. So 3.14 becomes 3, and so does 3.99. This can lead to significant arithmetic error. (Insert graphic for automatic and explicit casting)</p>
        <p class="HeadingRunIn" MadCap:autonum="1.9 ">integer division</p>
        <p>When integers are divided, the remainder is discarded. The results may not be what one would expect. 4/3 is equal to 1. For exact results, use floating point types.</p>
        <p>Java also provides an operation called <i>modulus</i>, which calculates the remainder of integer division. For example, 4 % 2 is equal to 0, as there is no remainder. 3 %  2 is equal to 1, the value of the remainder. Modulus is useful in a variety of contexts, i.e., dividing up objects among a group or for production cycles, when the remaining quantity of goods or materials is calculated.</p>
        <p class="HeadingRunIn" MadCap:autonum="1.10 ">additional arithmetic operators</p>
        <p>There are some operations performed so frequently that Java provides shorthand notation. It is very common to add or subtract one from a variable. This can be written as ++, the <i>increment operator</i>, or --, the <i>decrement operator.</i> The increment and decrement operators may be written as either a <i>prefix</i>, before the variable, or a <i>postfix</i>, after the variable. Caution: the results are not always the same. This is confusing, so sit tight.</p><pre>int x = 1;</pre><pre>int y;</pre><pre>int y = ++x;</pre><pre>int y = x++;</pre>
        <p>Believe it or not, in the first expression y is equal to 2 and x is equal to 2; in the second, y is equal to 1, while x is still equal to 2! You read that right; 1 = 2 in the second expression -- or so it would appear. <i>Only that is not the case.</i> We know by now that the equals sign in this context is initializing the variable <code>y</code>, not an equals sign.</p>
        <p>It works this way because the assignment to <code>y</code> in the first expression happens <i>after</i> <code>x</code> is incremented; in the second, <i>before</i> x is incremented. The value of <code>x</code> is 2 in both cases. </p>
        <p>Now, just in case you thought you were coming clear on the use of the equals sign in Java, there’s more: the assignment operators. These are of the form +=, - =, *=, /=. (insert table with complete list of assignment operators and cross reference) The expression:</p><pre>int x += 5;</pre>
        <p>Is the same as writing:</p><pre>int x = x + 5;</pre>
        <p>And similarly:</p><pre>int x *= 5;</pre>
        <p>Is the same as:</p><pre>x = x * 5;</pre>
        <p>In effect, the left hand side of the assignment is appended to the right hand side. These are easy to use, notwithstanding the repeated use of the equals sign to mean something other than equality. (insert table with all operators)</p>
        <p class="HeadingRunIn" MadCap:autonum="1.11 ">the java math library</p>
        <p>Java contains a library with dozens of the most common mathematical functions, from trigonometry to exponents to generating random numbers. This is one of many <i>standard libraries</i> available in Java. Methods from the math library use the following form:</p><pre>double result = Math.sin(x);</pre>
        <p>Where <code>x</code> is the angle in radians. <code>Math</code> followed by the <i>dot operator</i> refers to the math library, and <code>result</code> is of type <code>double.</code></p>
        <p>(Insert table of common math operations)</p>
        <p class="HeadingRunIn" MadCap:autonum="1.12 ">character arithmetic</p>
        <p>You will recall that all characters in Java are represented by 16 bit Unicode strings. So you might write the letter x, but the representation in memory is a 16 bit string. This means that the complete range of arithmetic operations are available on <code>char</code> types. This has greatest utility on operations with <i>Strings</i>, a data type we haven’t examined yet. (insert cross-reference) It can also be helpful for parsing files. Character arithmetic is not without its subtleties. Most important, when performing integer operations on <code>char</code> types, a cast to type <code>char</code> must always be included in the assignment. </p>
        <p>Let’s look first at an example using a <code>char</code> literal in the assignment.</p>
        <p style="font-family: 'Courier New';font-weight: normal;font-style: normal;font-size: 12pt;letter-spacing: 0em;color: #000000;text-decoration: none;"><code>char letter ='b' + 5;</code>
        </p>
        <p>As might be supposed, this expression evaluates to <code>g</code>. No cast is required because Java automatically recognizes the integer value of <code>'b'</code>. Things become more interesting when we use unrecognized <code>int</code> types in the assignment; Java requires an explicit cast. This example shows casting in action.</p><pre>char letter1 = 'm';</pre><pre>char letter2 = (char)('letter1' + 1);</pre><pre>char letter3 = 'l' + 2;</pre>
        <p>This outputs the letter <code>n</code> for both <code>letter2</code> and <code>letter3</code>. Note the use of the explicit cast to type <code>char</code> in the second line. As mentioned, the memory representation of type <code>char</code> primitives is Unicode -- hexadecimal. To maintain the compatibility with type <code>char</code> in the assignment, the explicit cast is required. It is also possible to cast to type <code>int</code> and return the decimal value of letters: a = 1, b = 2, and so forth. </p>
        <p class="HeadingRunIn" MadCap:autonum="1.13 ">binary and hexadecimal code</p>
        <p>As mentioned, computers run in binary code. While many -- if not most -- programmers will not have need of programming in binary code, it can be useful for certain operations, most notably as a status indicator: a particular bit is on or off, showing the status of an object. Binary, or bitwise, operations are also useful for memory management, where maximum computational speed is desired, or to communicate with hardware using the least abstraction. For those that are familiar with this material, just skip it. Those who are bored senseless by it can skip it, too.</p>
        <p>Let’s begin with ordinary decimal numbers as a starting point. The number 4444 can be represented as:</p>
        <p>4 * (10 X 10 X 10) + 4 * (10 X 10) + 4 * 10 + 4</p>
        <p>Put another way, it is 4E3 + 4E2 + 4E1 + 4E0. The exponents here are powers of ten; that’s what base ten means.</p>
        <p>Binary and hexadecimal numbers work the same way, with the exponents being two and sixteen, respectively. The binary number 1110 becomes:</p>
        <p>1 * (2 X 2 X 2) + 1 * (2 X 2) + 1 * 2 + 0 =</p>
        <p>8 + 4 + 2 + 0 = 14</p>
        <p>We run out of numerals using hexadecimal notation; 0-9 carry us only up to base 10, so the remaining 6 places use the letters A--F. The number 1AB3, we can infer by now, is:</p>
        <p>1 * (16 X 16 * 16) + 10 * (16 X 16) + 11 * 16 + 3 = 6835 </p>
        <h1>The Main Method; Strings; Printing</h1>
        <p class="HeadingRunIn" MadCap:autonum="1.14 ">the main method</p>
        <p>Every Java program has a so-called <cite>main method</cite>. If you have ever looked at Java code before, you may have noticed the line <code>public static void (main [] String args)</code>, which appears in every program -- this is the <code>main()</code> method. Don’t worry for now about what all that means; you’ll learn bit by bit in the remainder of the book. (insert cross reference) The key point for now is that the <code>main()</code> method passes the program to the Java Virtual Machine. One could say that it sits atop the hierarchy of everything else in a program. There can be more than one main method in an application, though typically there is only one. The <code>main()</code> method must always be written <code>public static void (main [] String args)</code>.</p>
        <p>The <code>main()</code> method is unique, apart from being the method that passes the program -- or more specifically, the arguments of the program -- to the JVM. A class which contains the <code>main()</code> method is often referred to as a <cite>client</cite> or <cite>test</cite> class. Client is a term with which you may be familiar from general knowledge of computing. On a network, a client computer represents a “spoke” in the familiar hub-and-spoke model of client/server networking. A class with the <code>main()</code> method acts as a kind of client of the other classes; it uses data and methods obtained from them. As a test class, developers use it to run methods written in other classes to see if those methods and accompanying data structures are performing as intended when written. Objects of data classes are created, or <cite>instantiated</cite>, in a class with the <code>main()</code> method, and both functional and unit tests are run on them.</p>
        <p class="HeadingRunIn" MadCap:autonum="1.15 ">strings</p>
        <p>Strings are not data primitives, but they act like them in certain ways. Most important, Strings are immutable; they cannot be changed implicitly like other objects. Do not expect to understand that yet; I note it for purposes of completeness.</p>
        <p>What you need to know about Strings at this point is that they are always written like this: <code>String</code>, with a capital S. String literals are always enclosed in double quotes. An example follows.</p><pre xml:space="preserve">String aphorism = "A penny saved is a penny earned." ;</pre>
        <p>And where multiple Strings appear, they are separated by a comma.</p><pre xml:space="preserve">"A penny saved is a penny earned", "A stitch in time saves nine", "Insert corny aphorism here." ;</pre>
        <p>Strings may also be concatenated for printing, by using the + sign and parentheses. Let's have a look at printing, where I will illustrate this with an example.</p>
        <p class="HeadingRunIn" MadCap:autonum="1.16 ">printing to the console</p>
        <p>First thing: we are not printing on a printer. We are printing to the "console," an anachronism left over from the early days where everything was done on a mainframe. Nowadays, we call it the monitor. Also, the print class is relatively complicated. The word system <code>System </code>simply refers to the System class, and the word <code>out </code>to the corresponding data stream which connects to the console. We are not interested in the complexity for now. I just want you to be able to execute simple output or to recognize a simple print statement. As promised, here is a print statement with concatenated Strings.</p><pre xml:space="preserve">System.out.println("Hark" + " Hark" +  " the" + " Dogs" + " Do" + " Bark.";</pre>
        <p>This prints, <code>Hark Hark the Dogs Do Bark</code>. Notice the extra spaces placed before each word; otherwise, they'd run into each other. Objects, including <code>String</code> objects, can always be joined by the use of the + sign.</p>
        <p>The statement <code>System.out.println()</code> prints to the console and adds a new line. If you don't want to add a new line, use <code>System.out.print()</code>. You could also use an escape sequence. <code>System.out.print( \n)</code>. This, you will recall, is the escape sequence for a new line. It is equivalent to <code>System.out.println()</code>.</p>
        <p>One further note concerning Strings and printing. When you print a variable which is of a type other than <code>String</code>, the compiler returns a <code>String </code>representation of that object. Again, there is hidden complexity here. Let the barking dogs bark, and the sleeping dogs lie for now. We'll address the fine points of this later.</p><pre xml:space="preserve"> public static void main(String[] args) {
        int number = 3;
        int anotherNumber = 2;
        int sum;
        
        sum = number + anotherNumber;
        
        System.out.println("The number returned is " + sum + ".");
    }
}</pre>
        <p>This produces the following output. <code>The number returned is 5.</code></p>
        <h1>Java Comments</h1>
        <p>Facilities for commenting code in Java are extensive, an integral part of the language. Comments are not code; they are non-functional. They serve merely to explain code. But a plain language explanation of what's going on may be the difference between understanding and not understanding somebody else's program.</p>
        <p>For general commenting, Java supports two formats. Single line comments take a double slash, //, and are generally seen at the end of a line or above a line. These are the most common form of comments. An example is above the print statement here.</p><pre xml:space="preserve">public static void main(String[] args) {
        int number = 3;
        int anotherNumber = 2;
        int sum;
        
        sum = number + anotherNumber;</pre><pre xml:space="preserve">
</pre><pre xml:space="preserve">// the print statement contains concatenated String objects
        System.out.println("The number returned is " + sum + ".");
    }
}</pre>
        <p>Java also supports multi-line comments. These are most typically seen at the beginning of a file, to explain in greater depth the purpose of the following code. A multiline comment begins with a slash and and asterisk, and continues until it is closed by a slash and a another asterisk.</p><pre xml:space="preserve">/* Here is an example of a multiline comment. The code below was written in the first instance to demonstrate the print statement and concatenation of strings. It is now being used to demonstrate a multiline comment.</pre><pre xml:space="preserve">/*</pre><pre xml:space="preserve">&#160;</pre><pre xml:space="preserve">public static void main(String[] args) {
        int number = 3;
        int anotherNumber = 2;
        int sum;
        
        sum = number + anotherNumber;
        
        System.out.println("The number returned is " + sum + ".");
    }
}</pre>
        <p>By convention, multiline comments terminate in the fashion depicted above, at the beginning of a line rather than at the end. Most IDEs enforce that format by default.</p>
        <p>Finally, we come to a type of comment unique to Java called documentation commenting, or <i>Javadocs</i>. Javadocs are tagged with the @ symbol and may be used for metadata about an application, in-line linking to another document, noting possible errors, or <i>exceptions</i> as they are known, and a variety of other purposes. Javadocs can be displayed in HTML or in the code font. The Java API, which you may have looked at, was created using Javadocs. Javadocs are a very powerful, tightly integrated provision for documenting code. (insert table containing tags)</p><pre xml:space="preserve">/**</pre><pre xml:space="preserve">* @author Andrew Redisch</pre><pre xml:space="preserve">/*</pre>
        <p>This is a Javadoc which simply notes the author of an application, in this case me.</p>
        <p>&#160;</p>
        <p>&#160;</p>
    </body>
</html>